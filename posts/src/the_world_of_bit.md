## 位运算的世界

> 由于对于位运算和集合之间的联系，在灵神的讨论中有详细讲解。这里便不再复述，我在此处仅记录我觉得好的题目，并写下我的想法



#### 3133.数组的最后一个元素    (位运算)

给你两个整数 `n` 和 `x` 。你需要构造一个长度为 `n` 的 **正整数** 数组 `nums` ，对于所有 `0 <= i < n - 1` ，满足 `nums[i + 1]` **大于** `nums[i]` ，并且数组 `nums` 中所有元素的按位 `AND` 运算结果为 `x` 。

返回 `nums[n - 1]` 可能的 **最小** 值。

 **示例 1：**

**输入：**n = 3, x = 4

**输出：**6

**解释：**

数组 `nums` 可以是 `[4,5,6]` ，最后一个元素为 `6` 。



##### 思路与解析：

对于位运算题目，我们可以将其与集合建立起联系。在此题中，x是每个nuns[i]的子集，如x = 100100，一定在一下序列中：

<div align="center"> 100101, 100111, 101100, 10101.... </div>

通过观察我们可以知道，序列的内容就是将x与从0到n-1的数进行数位嵌合。

为了让 nums[n−1] 尽量小，我们应当选择 x 的超集中最小的 n 个数。

所以把 x 的二进制中的 0 视作「空位」，往空位上填入 n−1，即为最小的 nums[n−1]。

如果空位不足，往 x 的前面添加前导零即可。



##### 代码如下：

```java
class Solution {
    public long minEnd(int n, int x) {
        n--;
        long ans = x;
        int i = 0, j = 0;
        while((n >> j) > 0){
            // x 的第 i 个比特值是 0，即「空位」
            if((ans >> i & 1) == 0){
                // 空位填入 n 的第 j 个比特值
                ans |= (long) (n >> j & 1) << i;
                j++;
            }
            i++;
        }
        return ans;
    }
}
```



##### 需要注意的一些地方：

在写位运算题目时，我们时常可以将位运算与集合相联系。将位运算问题转换为集合问题。像是数位DP也是同理。因为单独处理比特位十分麻烦。



